= 方法

`Go` 没有类。不过可以为结构体类型定义方法。方法就是一类带特殊的*接收者*参数的函数。方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。在此例中，`Abs` 方法拥有一个名为 `v`，类型为 `Vertex` 的接收者。

== &sect; 基础语法

[source,golang]
----
include::example$methods.go[tag=method-1]
----

.为非结构体类型声明方法
[source,golang]
----
include::example$methods.go[tag=method-2]
----

在此例中，我们看到了一个带 `Abs` 方法的数值类型 `MyFloat`。你只能为在同一包内定义的类型的接收者声明方法，而不能为其它包内定义的类型（包括 int 之类的内建类型）的接收者声明方法。

.指针接收者
[source,golang]
----
include::example$methods.go[tag=method-3]
----
<1> 方法与指针重定向，被编译为 `(&v).Scale`
<2> 被编译为 `(*p).Abs`

你可以为指针接收者声明方法。这意味着对于某类型 `T`，接收者的类型可以用 `*T` 的文法。（此外，`T` 不能是像 `*int` 这样的指针。）

例如，这里为 `*Vertex` 定义了 `Scale` 方法。指针接收者的方法可以修改接收者指向的值（就像 `Scale` 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。

若使用值接收者，那么 `Scale` 方法会对原始 `Vertex` 值的副本进行操作。（对于函数的其它参数也是如此。）`Scale` 方法必须用指针接受者来更改 `main` 函数中声明的 `Vertex` 的值。

=== 选择值或指针作为接收者

使用指针接收者的原因有二：

. 方法能够修改其接收者指向的值
. 可以避免在每次调用方法时复制该值。若值的类型为大型结构体时，这样做会更加高效

通常来说，所有给定类型的方法都应该有值或指针接收者，但并不应该二者混用。
