= 数据类型

== &sect; 指针

.基础语法
[source,golang]
----
include::example$datatypes.go[tag=pointer]
----

`Go` 拥有指针。指针保存了值的内存地址。与 `C` 不同，`Go` 没有指针运算。

== &sect; 结构体

.基础语法
[source,golang]
----
include::example$datatypes.go[tag=struct]
----
<1> 定义 `struct` 类型
<2> 字段
<3> 用指针访问 `struct` 字段的时候也是是使用 `.`

一个结构体（`struct`）就是一组字段（`field`）。结构体字段使用点号来访问。

结构体字段可以通过结构体指针来访问。如果我们有一个指向结构体的指针 p，那么可以通过 (*p).X 来访问其字段 X。不过这么写太啰嗦了，所以语言也允许我们使用隐式间接引用，直接写 p.X 就可以。

结构体文法通过直接列出字段的值来新分配一个结构体。使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关）特殊的前缀 `&` 返回一个指向结构体的指针。

== &sect; 数组

.基础语法
[source,golang]
----
include::example$datatypes.go[tag=array]
----

类型 `[n]T` 表示拥有 `n` 个 `T` 类型的值的数组。数组的长度是其类型的一部分，因此数组不能改变大小。这看起来是个限制，不过没关系，`Go` 提供了更加便利的方式来使用数组。

== &sect; 切片

.基础语法
[source,golang]
----
include::example$datatypes.go[tag=slice-1]
----
<1> 创建一个切片，它包含 `primes` 中下标从 1 到 3 的元素

每个数组的大小都是固定的。而切片则为数组元素提供动态大小的、灵活的视角。在实践中，切片比数组更常用。类型 `[]T` 表示一个元素类型为 `T` 的切片。

切片通过两个下标来界定，即一个上界和一个下界，二者以冒号分隔。它会选择一个半开区间，包括第一个元素，但排除最后一个元素。

切片文法类似于没有长度的数组文法。

.这是一个数组文法：
[source,golang]
----
[3]bool{true, true, false}
----

.下面这样则会创建一个和上面相同的数组，然后构建一个引用了它的切片：
[source,golang]
----
[]bool{true, true, false}
----

.切片就像数组的引用
[source,golang]
----
include::example$datatypes.go[tag=slice-2]
----

切片并不存储任何数据，它只是描述了底层数组中的一段。更改切片的元素会修改其底层数组中对应的元素。与它共享底层数组的切片都会观测到这些修改。

.切片的默认行为
[source,golang]
----
include::example$datatypes.go[tag=slice-3]
----

在进行切片时，你可以利用它的默认行为来忽略上下界。切片下界的默认值为 0，上界则是该切片的长度。

.切片的长度与容量
[source,golang]
----
include::example$datatypes.go[tag=slice-4]
----

.Print Slice
[source,golang]
----
include::example$datatypes.go[tag=print-slice]
----

切片拥有 长度 和 容量。切片的长度就是它所包含的元素个数。切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。切片 `s` 的长度和容量可通过表达式 `len(s)` 和 `cap(s)` 来获取。

你可以通过重新切片来扩展一个切片，给它提供足够的容量。试着修改示例程序中的切片操作，向外扩展它的容量，看看会发生什么。

.`nil` 切片
[source,golang]
----
include::example$datatypes.go[tag=slice-5]
----
<1> 切片的零值是 `nil`。`nil` 切片的长度和容量为 0 且没有底层数组

.用 `make` 创建切片
[source,golang]
----
include::example$datatypes.go[tag=slice-6]
----

切片可以用内建函数 `make` 来创建，这也是你创建动态数组的方式。`make` 函数会分配一个元素为零值的数组并返回一个引用了它的切片：

[source,golang]
----
a := make([]int, 5)  // len(a)=5
----

要指定它的容量，需向 `make` 传入第三个参数：

[source,golang]
----
b := make([]int, 0, 5) // len(b)=0, cap(b)=5
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
----

.切片的切片
[source,golang]
----
include::example$datatypes.go[tag=slice-7]
----

切片可包含任何类型，甚至包括其它的切片。

.向切片追加元素
[source,golang]
----
include::example$datatypes.go[tag=slice-8]
----

为切片追加新的元素是种常用的操作，为此 `Go` 提供了内建的 `append` 函数。内建函数的文档对此函数有详细的介绍。`func append(s []T, vs ...T) []T`
`append` 的第一个参数 `s` 是一个元素类型为 `T` 的切片，其余类型为 `T` 的值将会追加到该切片的末尾。`append` 的结果是一个包含原切片所有元素加上新添加元素的切片。当 `s` 的底层数组太小，不足以容纳所有给定的值时，它就会分配一个更大的数组。返回的切片会指向这个新分配的数组。

（要了解关于切片的更多内容，请阅读文章 `Go` 切片：用法和本质。）
