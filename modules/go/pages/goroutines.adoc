= Goroutine

`goroutine` 是由 `Go` 运行时管理的轻量级线程。

== &sect; `go` 的语法

.`goroutine` 语法
[source,golang]
----
include::example$goroutines.go[tag=goroutine-1]
----
<1> 启动一个 `goroutine`
<2> 在 *主线程* 中执行 `say` 函数

`goroutine` 在相同的地址空间中运行，因此在访问共享的内存时必须进行同步。`sync` 包提供了这种能力，不过在 `Go` 中并不经常用到，因为还有其它的办法。

== &sect; `chan` 语法

.无缓冲的 `chan`
[source,golang]
----
include::example$goroutines.go[tag=goroutine-2]
----
<1> 将结果送入 `chan`
<2> 创建 `chan`，没有缓冲
<3> 从 `chan` 中接收数据

`chan` 是带有类型的管道，你可以通过它用信道操作符 `<-` 来发送或者接收值。默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 `goroutine` 可以在没有显式的锁或竞态变量的情况下进行同步。

.带缓冲的 `chan`
[source,golang]
----
include::example$goroutines.go[tag=goroutine-3]
----
<1> 创建一个带缓冲的 `chan`

`chan` 可以是 带缓冲的。将缓冲长度作为第二个参数提供给 `make` 可以初始化一个带缓冲的 `chan`。仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。

.`range` 和 `close`
[source,golang]
----
include::example$goroutines.go[tag=goroutine-4]
----
<1> 因为 `chan` 已经关闭，所以 `ok` 的值为 `false`

发送者可通过 `close` 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭。

循环 `for i := range c` 会不断从信道接收值，直到它被关闭。

*注意：* 只有发送者才能关闭 `chan`，而接收者不能。向一个已经关闭的 `chan` 发送数据会引发程序终止（panic）。

*还要注意：* `chan` 与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range` 循环。

.`select` 语法
[source,golang]
----
include::example$goroutines.go[tag=goroutine-5]
----

`select` 语句使一个 `goroutine` 可以等待多个 `chan` 操作。`select` 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。

.默认选择
[source,golang]
----
include::example$goroutines.go[tag=goroutine-6]
----
<1> 当其他 `chan` 阻塞的时候，会执行 `default` 分支

当 `select` 中的其它分支都没有准备好时，`default` 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 `default` 分支。

.`sync.Mutex`
[source,golang]
----
include::example$goroutines.go[tag=goroutine-7]
----